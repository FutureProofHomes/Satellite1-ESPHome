substitutions:
  led_ring_id: "satellite1_led_ring"

light:
  - platform: satellite1
    id: ${led_ring_id}
    name: LED Ring
    entity_category: config
    icon: "mdi:circle-outline"
    default_transition_length: 0ms
    restore_mode: RESTORE_DEFAULT_OFF
    effects:
      - addressable_lambda:
          name: "Waiting for Command"
          update_interval: 100ms
          lambda: |-
            auto light_color = id(satellite1_led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (int i = 0; i < 24; i++) {
              if (i == id(global_led_animation_index) % 24) {
                it[i] = color;
              } else if (i == (id(global_led_animation_index) + 11) % 24) {
                it[i] = color * 192;
              } else if (i == (id(global_led_animation_index) + 10) % 24) {
                it[i] = color * 128;
              } else if (i == (id(global_led_animation_index) + 6) % 24) {
                it[i] = color;
              } else if (i == (id(global_led_animation_index) + 5) % 24) {
                it[i] = color * 192;
              } else if (i == (id(global_led_animation_index) + 4) % 24) {
                it[i] = color * 128;
              } else {
                it[i] = Color::BLACK;
              }
            }
            id(global_led_animation_index) = (id(global_led_animation_index) + 1) % 24;
      - addressable_lambda:
          name: "Listening For Command"
          update_interval: 50ms
          lambda: |-
            auto light_color = id(satellite1_led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (int i = 0; i < 24; i++) {
              if (i == id(global_led_animation_index) % 24) {
                it[i] = color;
              } else if (i == (id(global_led_animation_index) + 11) % 24) {
                it[i] = color * 192;
              } else if (i == (id(global_led_animation_index) + 10) % 24) {
                it[i] = color * 128;
              } else if (i == (id(global_led_animation_index) + 6) % 24) {
                it[i] = color;
              } else if (i == (id(global_led_animation_index) + 5) % 24) {
                it[i] = color * 192;
              } else if (i == (id(global_led_animation_index) + 4) % 24) {
                it[i] = color * 128;
              } else {
                it[i] = Color::BLACK;
              }
            }
            id(global_led_animation_index) = (id(global_led_animation_index) + 1) % 24;
      - addressable_lambda:
          name: "Thinking"
          update_interval: 10ms
          lambda: |-
            static uint8_t brightness_step = 0;
            static bool brightness_decreasing = true;
            static uint8_t brightness_step_number = 10;
            if (initial_run) {
              brightness_step = 0;
              brightness_decreasing = true;
            }
            auto light_color = id(satellite1_led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (int i = 0; i < 24; i++) {
              if (i == id(global_led_animation_index) % 24) {
                it[i] = color * uint8_t(255/brightness_step_number*(brightness_step_number-brightness_step));
              } else if (i == (id(global_led_animation_index) + 6) % 24) {
                it[i] = color * uint8_t(255/brightness_step_number*(brightness_step_number-brightness_step));
              } else {
                it[i] = Color::BLACK;
              }
            }
            if (brightness_decreasing) {
              brightness_step++;
            } else {
              brightness_step--;
            }
            if (brightness_step == 0 || brightness_step == brightness_step_number) {
              brightness_decreasing = !brightness_decreasing;
            }
      - addressable_lambda:
          name: "Replying"
          update_interval: 50ms
          lambda: |-
            id(global_led_animation_index) = (24 + id(global_led_animation_index) - 1) % 24;
            auto light_color = id(satellite1_led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            for (int i = 0; i < 24; i++) {
              if (i == (id(global_led_animation_index)) % 24) {
                it[i] = color;
              } else if (i == ( id(global_led_animation_index) + 1) % 24) {
                it[i] = color * 192;
              } else if (i == ( id(global_led_animation_index) + 2) % 24) {
                it[i] = color * 128;
              } else if (i == ( id(global_led_animation_index) + 6) % 24) {
                it[i] = color;
              } else if (i == ( id(global_led_animation_index) + 7) % 24) {
                it[i] = color * 192;
              } else if (i == ( id(global_led_animation_index) + 8) % 24) {
                it[i] = color * 128;
              } else {
                it[i] = Color::BLACK;
              }
            }
      - addressable_lambda:
          name: "Muted or Silent"
          update_interval: 16ms
          lambda: |-
            static int8_t index = 0;
            Color color(255, 0, 0);
            for (int i = 0; i < 24; i++) {
              if (i == 3  && id(master_mute_switch).state ) {
                it[i] = color;
              } else if (i == 9 && id(master_mute_switch).state ) {
                it[i] = color;
              } else if (i == 6 && (id(nabu_media_player).volume == 0.0f || id(nabu_media_player).is_muted()) ) {
                it[i] = color;
              } else {
                it[i] = Color::BLACK;
              }
            }
      - addressable_lambda:
          name: "Volume Display"
          update_interval: 50ms
          lambda: |-
            auto light_color = id(satellite1_led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            Color silenced_color(255, 0, 0);
            auto nb_leds_on = 24.0f * id(nabu_media_player).volume;
            for (int i = 0; i < 24; i++) {
              if (i < nb_leds_on) {
                it[(6+i)%24] = color;
              } else {
                it[(6+i)%24] = Color::BLACK;
              }
            }
            if (id(nabu_media_player).volume == 0.0f) {
              it[6] = silenced_color * 128;
            }
      # - addressable_lambda:
      #     name: "Center Button Touched"
      #     update_interval: 16ms
      #     lambda: |-
      #       if (initial_run) {
      #         // set voice_assistant_leds light to colors based on led_ring
      #         auto led_ring_cv = id(satellite1_led_ring).current_values;
      #         auto va_leds_call = id(voice_assistant_leds).make_call();
      #         va_leds_call.from_light_color_values(led_ring_cv);
      #         va_leds_call.set_brightness(1.0);
      #         va_leds_call.set_state(true);
      #         va_leds_call.perform();
      #       }
      #       auto light_color = id(voice_assistant_leds).current_values;
      #       Color color(light_color.get_red() * 255, light_color.get_green() * 255,
      #             light_color.get_blue() * 255);
      #       for (int i = 0; i < 12; i++) {
      #         it[i] = color;
      #       }
      - addressable_twinkle:
          name: "Twinkle"
          twinkle_probability: 50%
      - pulse:
          name: "Fast Pulse"
          transition_length: 100ms
          update_interval: 100ms
          min_brightness: 50%
          max_brightness: 100%
      - addressable_lambda:
          name: "Timer Ring"
          update_interval: 10ms
          lambda: |-
            static uint8_t brightness_step = 0;
            static bool brightness_decreasing = true;
            static uint8_t brightness_step_number = 10;
            if (initial_run) {
              brightness_step = 0;
              brightness_decreasing = true;
            }
            auto light_color = id(satellite1_led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            Color muted_color(255, 0, 0);
            for (int i = 0; i < 24; i++) {
              it[i] = color * uint8_t(255/brightness_step_number*(brightness_step_number-brightness_step));
            }
            if ( id(master_mute_switch).state ) {
              it[3] = muted_color;
              it[9] = muted_color;
            }
            if (brightness_decreasing) {
              brightness_step++;
            } else {
              brightness_step--;
            }
            if (brightness_step == 0 || brightness_step == brightness_step_number) {
              brightness_decreasing = !brightness_decreasing;
            }
      - addressable_lambda:
          name: "Timer Tick"
          update_interval: 100ms
          lambda: |-
            auto light_color = id(satellite1_led_ring).current_values;
            Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                  light_color.get_blue() * 255);
            Color muted_color(255, 0, 0);
            auto timer_ratio = 24.0f * id(first_active_timer).seconds_left / max(id(first_active_timer).total_seconds , static_cast<uint32_t>(1));
            uint8_t last_led_on = static_cast<uint8_t>(ceil(timer_ratio)) - 1;
            for (int i = 0; i < 24; i++) {
              float brightness_dip = ( i == id(global_led_animation_index) % 24 && i != last_led_on ) ? 0.9f : 1.0f ;
              if (i <= timer_ratio) {
                it[i] = color * min (255.0f * brightness_dip * (timer_ratio - i) , 255.0f * brightness_dip) ;
              } else {
                it[i] = Color::BLACK;
              }
            }
            if (id(master_mute_switch).state) {
              it[2] = Color::BLACK;
              it[3] = muted_color;
              it[4] = Color::BLACK;
              it[8] = Color::BLACK;
              it[9] = muted_color;
              it[10] = Color::BLACK;
            }
            id(global_led_animation_index) = (24 + id(global_led_animation_index) - 1) % 24;
      - addressable_rainbow:
          name: "Rainbow"
          width: 24
      - addressable_lambda:
          name: "Tick"
          update_interval: 333ms
          lambda: |-
            static uint8_t index = 0;
            Color color(255, 0, 0);
            if (initial_run) {
              index = 0;
            }
            for (int i = 0; i < 24; i++) {
              if (i <= index ) {
                it[i] = Color::BLACK;
              } else {
                it[i] = color;
              }
            }
            index = (index + 1) % 24;
      - addressable_lambda:
          name: "Factory Reset Coming Up"
          update_interval: 1s
          lambda: |-
            static uint8_t index = 0;
            Color color(255, 0, 0);
            if (initial_run) {
              index = 0;
            }
            for (int i = 0; i < 24; i++) {
              if (i <= index ) {
                it[i] = color;
              } else {
                it[i] = Color::BLACK;
              }
            }
            index = (index + 1) % 24;
      - addressable_lambda:
          name: "Jack Plugged"
          update_interval: 40ms
          lambda: |-
              static uint8_t index = 0;
              if (initial_run) {
                index = 0;
              }
              auto light_color = id(satellite1_led_ring).current_values;
              Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                    light_color.get_blue() * 255);
              if (index <= 6) {
                for (int i = 0; i < 24; i++) {
                  if (i == index) {
                    it[i] = color;
                  } else if (i == (24 - index) % 24) {
                    it[i] = color;
                  } else {
                    it[i] = Color::BLACK;
                  }
                }
              }
              index = (index + 1);
      - addressable_lambda:
          name: "Jack Unplugged"
          update_interval: 40ms
          lambda: |-
              static uint8_t index = 0;
              if (initial_run) {
                index = 0;
              }
              auto light_color = id(satellite1_led_ring).current_values;
              Color color(light_color.get_red() * 255, light_color.get_green() * 255,
                    light_color.get_blue() * 255);
              if (index <= 6) {
                for (int i = 0; i < 24; i++) {
                  if (i == 6 - index) {
                    it[i] = color;
                  } else if (i == (6 + index) % 24) {
                    it[i] = color;
                  } else {
                    it[i] = Color::BLACK;
                  }
                }
              }
              index = (index + 1);



script:
  # Master script controlling the LEDs, based on different conditions : initialization in progress, wifi and api connected and voice assistant phase.
  # For the sake of simplicity and re-usability, the script calls child scripts defined below.
  # This script will be called every time one of these conditions is changing.
  - id: control_leds
    then:
      - lambda: |
          if (id(improv_ble_in_progress)) {
            id(control_leds_improv_ble_state).execute();
          } else if (id(init_in_progress)) {
            id(control_leds_init_state).execute();
          } else if (!id(wifi_id).is_connected() || !id(api_id).is_connected()){
            id(control_leds_no_ha_connection_state).execute();
          } else if (id(jack_plugged_recently)) {
            id(control_leds_jack_plugged_recently).execute();
          } else if (id(jack_unplugged_recently)) {
            id(control_leds_jack_unplugged_recently).execute();
          } else if (id(dial_touched)) {
            id(control_leds_dial_touched).execute();
          } else if (id(timer_ringing).state) {
            id(control_leds_timer_ringing).execute();
          } else if (id(voice_assistant_phase) == ${voice_assist_waiting_for_command_phase_id}) {
            id(control_leds_voice_assistant_waiting_for_command_phase).execute();
          } else if (id(voice_assistant_phase) == ${voice_assist_listening_for_command_phase_id}) {
            id(control_leds_voice_assistant_listening_for_command_phase).execute();
          } else if (id(voice_assistant_phase) == ${voice_assist_thinking_phase_id}) {
            id(control_leds_voice_assistant_thinking_phase).execute();
          } else if (id(voice_assistant_phase) == ${voice_assist_replying_phase_id}) {
            id(control_leds_voice_assistant_replying_phase).execute();
          } else if (id(voice_assistant_phase) == ${voice_assist_error_phase_id}) {
            id(control_leds_voice_assistant_error_phase).execute();
          } else if (id(voice_assistant_phase) == ${voice_assist_not_ready_phase_id}) {
            id(control_leds_voice_assistant_not_ready_phase).execute();
          } else if (id(is_timer_active)) {
            id(control_leds_timer_ticking).execute();
          } else if (id(master_mute_switch).state) {
            id(control_leds_muted_or_silent).execute();
          } else if (id(nabu_media_player).volume == 0.0f || id(nabu_media_player).is_muted()) {
            id(control_leds_muted_or_silent).execute();
          } else if (id(voice_assistant_phase) == ${voice_assist_idle_phase_id}) {
            id(control_leds_voice_assistant_idle_phase).execute();
          }

  # Script executed during Improv BLE
  # Warm White Twinkle
  - id: control_leds_improv_ble_state
    then:
      - light.turn_on:
          brightness: 100%
          red: 100%
          green: 89%
          blue: 71%
          id: satellite1_led_ring
          effect: "Twinkle"

  # Script executed during initialization
  # Blue Twinkle if Wifi is connected, Else solid warm white
  - id: control_leds_init_state
    then:
      - if:
          condition:
            wifi.connected:
          then:
            - light.turn_on:
                brightness: 100%
                red: 9.4%
                green: 73.3%
                blue: 94.9%
                id: satellite1_led_ring
                effect: "Twinkle"
          else:
            - light.turn_on:
                brightness: 50%
                red: 100%
                green: 89%
                blue: 71%
                id: satellite1_led_ring
                effect: "none"

  # Script executed when the device has no connection to Home Assistant
  # Red Twinkle (This will be visible during HA updates for example)
  - id: control_leds_no_ha_connection_state
    then:
      - light.turn_on:
          brightness: 100%
          red: 1
          green: 0
          blue: 0
          id: satellite1_led_ring
          effect: "Twinkle"

  # Script executed when the voice assistant is idle (waiting for a wake word)
  # Nothing (Either LED ring off or LED ring on if the user decided to turn the user facing LED ring on)
  - id: control_leds_voice_assistant_idle_phase
    then:
      - light.turn_off: satellite1_led_ring
      - if:
          condition:
            light.is_on: ${led_ring_id}
          then:
            light.turn_on: ${led_ring_id}

  # Script executed when the voice assistant is waiting for a command (After the wake word)
  # Slow clockwise spin of the LED ring.
  - id: control_leds_voice_assistant_waiting_for_command_phase
    then:
      - light.turn_on:
          brightness: !lambda return id(satellite1_led_ring).current_values.get_brightness();
          id: satellite1_led_ring
          effect: "Waiting for Command"

  # Script executed when the voice assistant is listening to a command
  # Fast clockwise spin of the LED ring.
  - id: control_leds_voice_assistant_listening_for_command_phase
    then:
      - light.turn_on:
          brightness: !lambda return id(satellite1_led_ring).current_values.get_brightness();
          id: satellite1_led_ring
          effect: "Listening For Command"

  # Script executed when the voice assistant is thinking to a command
  # The spin stops and the 2 LEDs that are currently on and blinking indicating the commend is being processed.
  - id: control_leds_voice_assistant_thinking_phase
    then:
      - light.turn_on:
          brightness: !lambda return id(satellite1_led_ring).current_values.get_brightness();
          id: satellite1_led_ring
          effect: "Thinking"

  # Script executed when the voice assistant is thinking to a command
  # Fast anticlockwise spin of the LED ring.
  - id: control_leds_voice_assistant_replying_phase
    then:
      - light.turn_on:
          brightness: !lambda return id(satellite1_led_ring).current_values.get_brightness();
          id: satellite1_led_ring
          effect: "Replying"

  # Script executed when the voice assistant is in error
  # Fast Red Pulse
  - id: control_leds_voice_assistant_error_phase
    then:
      - light.turn_on:
          brightness: 100%
          red: 1
          green: 0
          blue: 0
          id: satellite1_led_ring
          effect: "Fast Pulse"

  # Script executed when the voice assistant is muted or silent
  # The LED next to the 2 microphones turn red / one red LED next to the speaker grill
  - id: control_leds_muted_or_silent
    then:
      - light.turn_on:
          brightness: !lambda return id(satellite1_led_ring).current_values.get_brightness();
          id: satellite1_led_ring
          effect: "Muted or Silent"

  # Script executed when the voice assistant is not ready
  - id: control_leds_voice_assistant_not_ready_phase
    then:
      - light.turn_on:
          brightness: 100%
          red: 1
          green: 0
          blue: 0
          id: satellite1_led_ring
          effect: "Twinkle"

  # Script executed when the dial is touched
  # A number of LEDs turn on indicating a visual representation of the volume of the media player entity.
  - id: control_leds_dial_touched
    then:
      - light.turn_on:
          brightness: 100%
          id: satellite1_led_ring
          effect: "Volume Display"

  # Script executed when the jack has just been unplugged
  # A ripple effect
  - id: control_leds_jack_unplugged_recently
    then:
      - light.turn_on:
          brightness: 100%
          id: satellite1_led_ring
          effect: "Jack Unplugged"

  # Script executed when the jack has just been plugged
  # A ripple effect
  - id: control_leds_jack_plugged_recently
    then:
      - light.turn_on:
          brightness: 100%
          id: satellite1_led_ring
          effect: "Jack Plugged"

  # Script executed when the center button is touched
  # The complete LED ring turns on
  - id: control_leds_center_button_touched
    then:
      - light.turn_on:
          brightness: 100%
          id: satellite1_led_ring
          effect: "Center Button Touched"

  # Script executed when the timer is ringing, to control the LEDs
  # The LED ring blinks.
  - id: control_leds_timer_ringing
    then:
      - light.turn_on:
          brightness: 100%
          id: satellite1_led_ring
          effect: "Timer Ring"

  # Script executed when the timer is ticking, to control the LEDs
  # The LEDs shows the remaining time as a fraction of the full ring.
  - id: control_leds_timer_ticking
    then:
      - light.turn_on:
          brightness: !lambda return id(satellite1_led_ring).current_values.get_brightness();
          id: satellite1_led_ring
          effect: "Timer tick"

  # Script executed when the volume is increased/decreased from the dial
  - id: control_volume
    mode: restart
    parameters:
      increase_volume: bool  # True: Increase volume / False: Decrease volume.
    then:
      - delay: 16ms
      - if:
          condition:
            lambda: return increase_volume;
          then:
            - media_player.volume_up:
          else:
            - media_player.volume_down:
      - script.execute: control_leds
      # - delay: 1s
      # - lambda: id(dial_touched) = false;
      # - sensor.rotary_encoder.set_value:
      #     id: dial
      #     value: 0
      - script.execute: control_leds